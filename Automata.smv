-- Current issues: why is it assigning insane values to s.balance? 
-- Current issue: how to stop s.balance from overflowing/underflowing? 
-- Perhaps the problem is that non-determinism must also be specified.

MODULE crowdState
	VAR
		owner : 0..10;
		max_block : 0..20;
		goal : 0..400;
		funded : boolean; 		
		backerb : array 0..10 of boolean; 
		backeramt : array 0..10 of 0..20;
	ASSIGN
		init(owner) := 0;
		init(goal) := 7; 
		init(max_block) := 16;
		init(funded) := FALSE;
		init(backerb[0]) := FALSE;
		init(backerb[1]) := FALSE;
		init(backerb[2]) := FALSE;
		init(backerb[3]) := FALSE;
		init(backerb[4]) := FALSE;
		init(backerb[5]) := FALSE;
		init(backerb[6]) := FALSE;
		init(backerb[7]) := FALSE;
		init(backerb[8]) := FALSE;
		init(backerb[9]) := FALSE;
		init(backerb[10]) := FALSE;
		init(backeramt[0]) := 0;
		init(backeramt[1]) := 0;
		init(backeramt[2]) := 0;
		init(backeramt[3]) := 0;
		init(backeramt[4]) := 0;
		init(backeramt[5]) := 0;
		init(backeramt[6]) := 0;
		init(backeramt[7]) := 0;
		init(backeramt[8]) := 0;
		init(backeramt[9]) := 0;
		init(backeramt[10]) := 0;

MODULE cstate(crowdState)
	VAR
		accountID : 0..10;
		balance : 0..400;
		cs : crowdState;
	ASSIGN
		init(accountID) := 0;
		init(balance) := 1;

MODULE message
	VAR
		value : 0..20;
		sender : 0..10;
		receiver : 0..10;
		tag : {0, 1, 2, 3};
		body : {ok_msg, no_msg};
	ASSIGN
		init(value) := 0;
		init(sender) := 0;
		init(receiver) := 0;
		init(tag) := 0;
		init(body) := no_msg;

MODULE symbolicmessage 
	VAR
		value : {money_back, no_such_luck};
		sender : 0..10;
		receiver : 0..10;
		body : {ok_msg, no_msg};
	ASSIGN
		init(value) := no_such_luck;
		init(sender) := 0;
		init(receiver) := 0;
		init(body) := no_msg;

MODULE main
	VAR 
		b : 0..20;
		inFlight : message;
		outFlight : symbolicmessage;
		s : cstate(crowdState);
		dead : boolean;

	ASSIGN
		-- Importantly, the state does not actually process the out message 
		-- The out message merely serves as information sent back to user
		init(b) := 0;
		init(dead) := FALSE;
		next(dead) := 
		case (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & !(s.balance + inFlight.value < 10000)) : TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (1 = inFlight.sender) & s.cs.backerb[1] & (s.balance - s.cs.backeramt[1] < 0)) : TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (2 = inFlight.sender) & s.cs.backerb[2] & (s.balance - s.cs.backeramt[2] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (3 = inFlight.sender) & s.cs.backerb[3] & (s.balance - s.cs.backeramt[3] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (4 = inFlight.sender) & s.cs.backerb[4] & (s.balance - s.cs.backeramt[4] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (5 = inFlight.sender) & s.cs.backerb[5] & (s.balance - s.cs.backeramt[5] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (6 = inFlight.sender) & s.cs.backerb[6] & (s.balance - s.cs.backeramt[6] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (7 = inFlight.sender) & s.cs.backerb[7] & (s.balance - s.cs.backeramt[7] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (8 = inFlight.sender) & s.cs.backerb[8] & (s.balance - s.cs.backeramt[8] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (9 = inFlight.sender) & s.cs.backerb[9] & (s.balance - s.cs.backeramt[9] < 0)) :  TRUE;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (10 = inFlight.sender) & s.cs.backerb[10] & (s.balance - s.cs.backeramt[10] < 0)) : TRUE;
			 TRUE : FALSE;
		esac;

		-- Incrementing the blocknumber with each state transition
		next(b) := 
		case (b = 20) : b; 
			 TRUE : b + 1;
		esac;

		-- ---------------------------------- --
	 	-- Handling contract state variables  -- 
	 	-- ---------------------------------- --
		next(s.accountID) := s.accountID;
		-- Manipulating the contract balance
		next(s.balance) := 
		case (dead) : s.balance;
			 -- Only looking at the cases where s.balance is actually changed, the rest is under "TRUE"
			 -- Donation is successful, (2)
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & (s.balance + inFlight.value <= 400)) : (s.balance + 1) mod 400;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & (s.balance + inFlight.value > 400)) : s.balance;
			 -- Getfunds is successful, (4)
			 (inFlight.tag = 2 & timeup & goalmet) : 0;
			 -- Refund is successful, (9)
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (1 = inFlight.sender) & s.cs.backerb[1] & !(s.balance - s.cs.backeramt[1] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (2 = inFlight.sender) & s.cs.backerb[2] & !(s.balance - s.cs.backeramt[2] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (3 = inFlight.sender) & s.cs.backerb[3] & !(s.balance - s.cs.backeramt[3] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (4 = inFlight.sender) & s.cs.backerb[4] & !(s.balance - s.cs.backeramt[4] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (5 = inFlight.sender) & s.cs.backerb[5] & !(s.balance - s.cs.backeramt[5] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (6 = inFlight.sender) & s.cs.backerb[6] & !(s.balance - s.cs.backeramt[6] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (7 = inFlight.sender) & s.cs.backerb[7] & !(s.balance - s.cs.backeramt[7] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (8 = inFlight.sender) & s.cs.backerb[8] & !(s.balance - s.cs.backeramt[8] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (9 = inFlight.sender) & s.cs.backerb[9] & !(s.balance - s.cs.backeramt[9] < 0)) : s.balance - 0;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (10 = inFlight.sender) & s.cs.backerb[10] & !(s.balance - s.cs.backeramt[10] < 0)) : s.balance - 0;
			 TRUE : s.balance; 
	 	esac;

		-- ---------------------------------- --
	 	--   Handling crowd state variables   -- 
	 	-- ---------------------------------- --
	 	-- Keeping the constants constant 
		next(s.cs.owner) := s.cs.owner;
		next(s.cs.goal) := s.cs.goal;
		next(s.cs.max_block) := s.cs.max_block;

		-- Manipulating the funded flag
	 	next(s.cs.funded) := 
	 	case (dead) : s.cs.funded;
	 		-- Only if the owner successfully claims funds does the flag flip (4)
	 		(inFlight.tag = 2 & !timeup & goalmet) : TRUE;
	 		TRUE : FALSE;
	 	esac;

	 	-- Manipulating the backer-tracking arrays 
	 	-- Array entries are only changed if donate or refund are successful 

		-- Manipulating the backerb array 
		next(s.cs.backerb[1]) := 
	 	case (dead) : s.cs.backerb[1];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (1 = inFlight.sender) & s.cs.backerb[1]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 1) : TRUE;
			 TRUE : s.cs.backerb[1];
		esac;
		next(s.cs.backerb[2]) := 
	 	case (dead) : s.cs.backerb[2];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (2 = inFlight.sender) & s.cs.backerb[2]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 2) : TRUE;
			 TRUE : s.cs.backerb[2];
		esac;
		next(s.cs.backerb[3]) := 
	 	case (dead) : s.cs.backerb[3];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (3 = inFlight.sender) & s.cs.backerb[3]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 3) : TRUE;
			 TRUE : s.cs.backerb[3];
		esac;
		next(s.cs.backerb[4]) := 
	 	case (dead) : s.cs.backerb[4];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (4 = inFlight.sender) & s.cs.backerb[4]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 4) : TRUE;
			 TRUE : s.cs.backerb[4];
		esac;
		next(s.cs.backerb[5]) := 
	 	case (dead) : s.cs.backerb[5];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (5 = inFlight.sender) & s.cs.backerb[5]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 5) : TRUE;
			 TRUE : s.cs.backerb[5];
		esac;
		next(s.cs.backerb[6]) := 
	 	case (dead) : s.cs.backerb[6];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (6 = inFlight.sender) & s.cs.backerb[6]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 6) : TRUE;
			 TRUE : s.cs.backerb[6];
		esac;
		next(s.cs.backerb[7]) := 
	 	case (dead) : s.cs.backerb[7];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (7 = inFlight.sender) & s.cs.backerb[7]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 7) : TRUE;
			 TRUE : s.cs.backerb[7];
		esac;
		next(s.cs.backerb[8]) := 
	 	case (dead) : s.cs.backerb[8];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (8 = inFlight.sender) & s.cs.backerb[8]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 8) : TRUE;
			 TRUE : s.cs.backerb[8];
		esac;
		next(s.cs.backerb[9]) := 
	 	case (dead) : s.cs.backerb[9];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (9 = inFlight.sender) & s.cs.backerb[9]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 9) : TRUE;
			 TRUE : s.cs.backerb[9];
		esac;
		next(s.cs.backerb[10]) := 
	 	case (dead) : s.cs.backerb[10];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (10 = inFlight.sender) & s.cs.backerb[10]) : FALSE;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 10) : TRUE;
			 TRUE : s.cs.backerb[10];
		esac;


	 	-- Manipulating the backeramt array 
	 	next(s.cs.backeramt[1]) := 
	 	case (dead) : s.cs.backeramt[1];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (1 = inFlight.sender) & s.cs.backerb[1]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 1) : inFlight.value;
			 TRUE : s.cs.backeramt[1];
		esac;
		next(s.cs.backeramt[2]) := 
	 	case (dead) : s.cs.backeramt[2];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (2 = inFlight.sender) & s.cs.backerb[2]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 2) : inFlight.value;
			 TRUE : s.cs.backeramt[2];
		esac;
		next(s.cs.backeramt[3]) := 
	 	case (dead) : s.cs.backeramt[3];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (3 = inFlight.sender) & s.cs.backerb[3]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 3) : inFlight.value;
			 TRUE : s.cs.backeramt[3];
		esac;
		next(s.cs.backeramt[4]) := 
	 	case (dead) : s.cs.backeramt[4];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (4 = inFlight.sender) & s.cs.backerb[4]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 4) : inFlight.value;
			 TRUE : s.cs.backeramt[4];
		esac;
		next(s.cs.backeramt[5]) := 
	 	case (dead) : s.cs.backeramt[5];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (5 = inFlight.sender) & s.cs.backerb[5]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 5) : inFlight.value;
			 TRUE : s.cs.backeramt[5];
		esac;
		next(s.cs.backeramt[6]) := 
	 	case (dead) : s.cs.backeramt[6];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (6 = inFlight.sender) & s.cs.backerb[6]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 6) : inFlight.value;
			 TRUE : s.cs.backeramt[6];
		esac;
		next(s.cs.backeramt[7]) := 
	 	case (dead) : s.cs.backeramt[7];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (7 = inFlight.sender) & s.cs.backerb[7]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 7) : inFlight.value;
			 TRUE : s.cs.backeramt[7];
		esac;
		next(s.cs.backeramt[8]) := 
	 	case (dead) : s.cs.backeramt[8];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (8 = inFlight.sender) & s.cs.backerb[8]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 8) : inFlight.value;
			 TRUE : s.cs.backeramt[8];
		esac;
		next(s.cs.backeramt[9]) := 
	 	case (dead) : s.cs.backeramt[9];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (9 = inFlight.sender) & s.cs.backerb[9]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 9) : inFlight.value;
			 TRUE : s.cs.backeramt[9];
		esac;
		next(s.cs.backeramt[10]) := 
	 	case (dead) : s.cs.backeramt[10];
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (10 = inFlight.sender) & s.cs.backerb[10]) : 0;
			 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender]) & inFlight.sender = 10) : inFlight.value;
			 TRUE : s.cs.backeramt[10];
		esac;

	 	-- ---------------------------------- --
	 	-- Picking values for the out message -- 
	 	-- ---------------------------------- --

	 	-- Manipulating the out message value 
	 	next(outFlight.value) := 
	 	case (dead) : outFlight.value;
	 		 -- Getfunds is successful, (2)
			 (inFlight.tag = 2 & timeup & goalmet & inFlight.sender = 0) : money_back;
			 -- Refund is successful, (9)
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (1 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (2 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (3 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (4 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (5 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (6 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (7 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (8 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (9 = inFlight.sender)) : money_back;
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded) & (10 = inFlight.sender)) : money_back;
			 TRUE : no_such_luck;
		esac;
		-- Manipulating the out message sender 
		next(outFlight.sender) := 0;
		-- Manipulating the out message receiver
		next(outFlight.receiver) := case (dead) : outFlight.receiver;
										 TRUE : inFlight.sender;
									esac;
	 	-- Manipulating the out message body 
	 	next(outFlight.body) := 
	 	case (dead) : outFlight.body;
	 		 -- Donation is successful, (2)
	 		 (inFlight.tag = 1 & !timeup & !(s.cs.backerb[inFlight.sender])) : ok_msg;
	 		 -- Getfunds is successful, (4)
			 (inFlight.tag = 2 & !timeup & goalmet) : ok_msg;
	 		 -- Refund is successful, (9)
			 (inFlight.tag = 3 & timeup & !(goalmet | s.cs.funded)) : ok_msg;
			 TRUE : no_msg;
		esac;

	 	-- ---------------------------------- --
	 	-- Picking values for the in message  -- 
	 	-- ---------------------------------- --
		-- Everything else is left to non-determinism 
	 	next(inFlight.value) := 0..20;
	 	next(inFlight.sender) := 0..10;
		next(inFlight.receiver) := 0;
	 	next(inFlight.tag) := {1,2,3};
	 	next(inFlight.body) := ok_msg;


TRANS 
		next(s.balance) = s.balance | next(s.balance) = s.balance - s.cs.backeramt[1];
DEFINE
		-- Forcible flattening of quantified predicates into propositional logic 
		donated_1 := s.cs.backerb[1] = TRUE & s.cs.backeramt[1] > 0;
		donated_2 := s.cs.backerb[2] = TRUE & s.cs.backeramt[2] > 0;
		donated_3 := s.cs.backerb[3] = TRUE & s.cs.backeramt[3] > 0;
		donated_4 := s.cs.backerb[4] = TRUE & s.cs.backeramt[4] > 0;
		donated_5 := s.cs.backerb[5] = TRUE & s.cs.backeramt[5] > 0;
		donated_6 := s.cs.backerb[6] = TRUE & s.cs.backeramt[6] > 0;
		donated_7 := s.cs.backerb[7] = TRUE & s.cs.backeramt[7] > 0;
		donated_8 := s.cs.backerb[8] = TRUE & s.cs.backeramt[8] > 0;
		donated_9 := s.cs.backerb[9] = TRUE & s.cs.backeramt[9] > 0;
		donated_10 := s.cs.backerb[10] = TRUE & s.cs.backeramt[10] > 0;
		timeup := b > s.cs.max_block;
		goalmet := s.balance > s.cs.goal;
		success := s.cs.funded = TRUE;
		claimed_1 := outFlight.receiver = 1 & outFlight.value = money_back;
		claimed_2 := outFlight.receiver = 2 & outFlight.value = money_back;
		claimed_3 := outFlight.receiver = 3 & outFlight.value = money_back;
		claimed_4 := outFlight.receiver = 4 & outFlight.value = money_back;
		claimed_5 := outFlight.receiver = 5 & outFlight.value = money_back;
		claimed_6 := outFlight.receiver = 6 & outFlight.value = money_back;
		claimed_7 := outFlight.receiver = 7 & outFlight.value = money_back;
		claimed_8 := outFlight.receiver = 8 & outFlight.value = money_back;
		claimed_9 := outFlight.receiver = 9 & outFlight.value = money_back;
		claimed_10 := outFlight.receiver = 10 & outFlight.value = money_back;
INVARSPEC 
 		b < 21;
SPEC
 		A [donated_1 U (timeup & goalmet & success & claimed_1)];
SPEC
 		A [!timeup U timeup];
